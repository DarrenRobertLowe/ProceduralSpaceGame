<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Map Generation
/* This is where stages are built before the player
 * enters them.
 */
 
// A different generator could be used for varying types of stages.
// For example, one could be ancient runes or caverns, and be totally random.
// Another could be very methodical and for space ships.

// create a large grid to hold each room
ds_map_clear(global.GRID);
var finalMap = global.GRID;//ds_grid_create(20, 20); // this will be resized programatically

// decide on how many pieces there'll be on this map
var roomsToCreate = 1 + round(random(5));

// choose a chunk
var choice = round(random(ds_list_size(global.stageblocks)));
var block  = ds_list_find_value(global.stageblocks, choice);

var centreColumn = round(  ds_grid_width(finalMap) * 0.5);
var centreRow    = round( ds_grid_height(finalMap) * 0.5);
var startRoom    = ds_grid_set(finalMap, centreColumn, centreRow, choice);
var currentColumn = centreColumn;   // keeps track of our column as we create more roooms
var currentRow    = centreRow;      // keeps track of our row as we create more roooms
var targetColumn  = currentColumn;
var targetRow     = currentRow;
var directions    = ds_list_create();

// create an initial room
var choice = irandom(ds_list_size(global.stageblocks) - 1);
var block = ds_list_find_value(global.stageblocks, choice);

// this should loop
for (var i=roomsToCreate; roomsToCreate &gt; 0; roomsToCreate--) {
    // setup
    cellValid = false;
    ds_list_clear(directions);
    ds_list_add(directions, "north", "south", "east", "west");
    
    // try to place next cell
    while (cellValid == false) {
        // if we're out of directions to choose we have to end.
        if ((ds_list_size(directions)) == 0) {
            roomsToCreate = 0;
            break;
        }
        
        // choose a direction
        var direct = ds_list_find_value(directions, choose(ds_list_size(directions)));
        
        // place the block
        switch (direct) {
            case "north":
                targetColumn = currentColumn;
                targetRow = currentRow -1;
                break;
                
            case "south":
                targetColumn = currentColumn;
                targetRow = currentRow +1;
                break;
                
            case "east":
                targetColumn = currentColumn +1;
                targetRow = currentRow;
                break;
                
            case "west":
                targetColumn = currentColumn -1;
                targetRow = currentRow;
                break;
        }
        
        // invalid cell?
        if !(inBounds(targetColumn, targetRow, finalMap))
        or (ds_grid_get(finalMap, targetColumn, targetRow) != EMPTY) {
            ds_list_delete(directions, ds_list_find_index(directions, direct)); // remove e.g. "north" from available choices
        } else {
            cellValid = true;
            
            // connect map pieces together
            var choice = irandom(ds_list_size(global.stageblocks) - 1);
            var block  = ds_list_find_value(global.stageblocks, choice);
            roomsToCreate--;
        }
    }
}


// build the rooms
var mapWidth  = ds_grid_width(finalMap);
var mapHeight = ds_grid_height(finalMap);

// iterate through the finalMap
for (var outerColumn = 0; outerColumn &lt; mapWidth; outerColumn++) {
    for (var outerRow = 0; outerRow &lt; mapHeight; outerRow++) {
        // each cell represent a chunk with its own grid,
        // so now we need to build that. This is... not a fast
        // algorithm for doing this, but should be fine given the
        // small numbers involved.
        var chunk = ds_grid_get(finalMap, column, row);
        var chunkWidth  = ds_grid_width(chunk);
        var chunkHeight = ds_grid_height(chunk);
        
        for (var innerColumn = 0; innerColumn &lt; chunkWidth; innerColumn++) {
            for (var innerRow = 0; innerRow &lt; chunkHeight; innerRow++) {
                var content = ds_grid_get(chunk, innerColumn, innerRow);
                
                // we place the cell on the finalMap, so we need to adjust the coordinates
                var targetColumn = ((outerColumn * global.chunkWidth) + innerColumn);
                var targetRow    = ((outerRow * global.chunkHeight) + innerRow);
                build(targetColumn, targetRow, content);
            }
        }
    }
}


// programmatically fill in missing outer walls

// place an entrance point for the player
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
